# 05. 최신 자바스크립트 문법과 기능

최신 디자인 패턴을 이해하기 위해 ES2015 버전 잇아에서 지원하는 JS 기능과 문법을 살펴보자.

# 5.1 애플리케이션 분리의 중요성

- 모듈형 자바스크립트는 애플리케이션을 모듈이라는 단위로 쪼갤 수 있다
- 애플리케이션은 여러 개의 중첩된 모듈로 구성될 수 있다
- 모듈화로 이루어진 느슨한 결합이 유지보수를 용이하게 만든다
- ES5 이후부터 자바스크립트는 모듈을 자연스럽게 가져올 수 있게 되었다.

# 5.2 모듈 가져오기와 내보내기

- 모듈을 사용하면 각 기능별로 독립적이게 코드 분리가 가능하다
- 모듈은 코드의 재사용성 향상이 용이
- import 및 export 키워드로 모듈을 가져오고 내보낼 수 있다

```jsx
export const baker = {
...}

import baker from "...";
```

각각의 모듈을 이렇게 내보내고 가져올 수도 있고

```jsx
const baker = {};
const pastryChef = {};
const assistant = {};
export { baker, pastryChef, assistant };

import { baker, assistant } from '...';
```

한꺼번에 내보내고 필요한 모듈만 가져올 수도 있다.

# 5.3 모듈 객체

모듈을 객체로 가져온다면, 객체 하나만으로 여러 곳에 사용이 가능함.

# 5.4 외부 소스로부터 가져오는 모듈

ES2015부터 외부 소스에서 원격 모듈을 쉽게 가져올 수 있게 되었다.

```jsx
import {cakeFactory} From "https://example.com...";
```

해당 예시처럼 가져오는 방식은 **정적 가져오기**라고 칭한다. 실행 전, 모듈을 다운로드 하고 실행해야 하므로, 성능에 문제가 생길 수도 있다.

# 5.6 동적으로 모듈 가져오기

앞서 본 예시처럼 미리 다운로드 하는 것 보다, 필요한 시점에만 로드하는 것이 성능상 이로울 때가 많다.

지연 로딩(lazy-loading) 모듈을 사용하면 필요한 시점에 로드할 수 있다. 이게 바로 **동적 가져오기**가 생겨난 이유이다.

동적 가져오기를 사용하면 모듈이 사용될 때만 다운로드되고 실행된다.

```jsx
form.addEventListener("submit", e => {
	e.preventDefault();
	import("/modules/cakeFactory.js)
		.then((module) => {
			// 가져온 모듈 사용하기
			...
			});
		});
```

동적 가져오기는 **await**와 함께 사용할 수 있다.

```jsx
let module = await import('modules...');
```

## 5.6.1 사용자 상호작용에 따라 가져오기

페이지 로드 시점에 필요한 것이 아닌, 사용자가 컴포넌트를 클릭하는 등의 상호작용에 따라 일부 기능이 로드되어야 할 수 있다. 동적 가져오기를 활용한 예시를 보자.

```jsx
const btn = document.querySelector("button");
btn.addEventListener('click', e=>{
	e.preventDefault();
	import('...');
		.then(module ...);
```

## 5.6.2 화면에 보이면 가져오기

처음에 숨겨져 있다가, 아래로 스크롤 하면 화면이 나타나야 하는 경우에도 동적 가져오기를 사용하면 유용하다.

# 5.8 모듈 사용하면 생기는 이점

- 한 번만 실행된다
  - 기존 스크립트는 DOM에 추가될 때마다 실행되지만, 모듈 스크립트는 한 번만 실행됨.
  - 의존성 트리의 가장 내부에 위칳나 모듈이 먼저 실행됨
- 자동으로 지연 로드된다
  - 즉시 로드되지 않기 위해, 다른 스크립트 파일은 defer 속성을 붙임. 하지만 모듈은 자동으로 지연됨
- 유지보수와 재사용이 쉽다
- 네임스페이스를 제공한다
  - 모듈은 관련 변수와 상수를 위한 개별 공간을 생성하여, 글로벌 네임스페이스를 오염시키지 않음
- 사용하지 않는 코드를 제거한다
  - 웹팩이나 롤업같은 번들러를 사용해, 사용하지 않는 모듈을 제거할 수 있다
  - 사용하지 않는 코드를 제거하는 것을 ‘트리쉐이킹’이라고 한다

# 5.9 생성자, 게터, 세터를 가진 클래스

ES2015+에서는 생성자와 내부를 숨기는 기능을 가진 클래스가 추가되었다.

```jsx
class Cake {
  constructor(name, toppings) {
    // 생성자
    this.name = name;
    this.toppings = toppings;
  }

  get allToppings() {
    return this.toppings;
  }
  set name(name) {
    this.name = name;
  }
}
```

get, set 키워드를 통해 게터와 세터를 설정해줄 수 있다.

extends를 통해 클래스를 상속받을 수도 있다. super 키워드를 통해 부모 클래스의 메서드를 실행할 수도 있다.

```jsx
class BirthdayCake extends Cookie {
	...
	showTitle(){
		super.showTitlte();
		...
	}
}
```

또한, 멤버 앞에 #을 붙여 비공개로 설정할 수도 있다.\

```jsx
class Cookie {
  #privateField;
}
```

# 5.10 자바스크립트 프레임워크와 크래스

클래스의 대체제로 도입된 **리액트 Hooks**를 통해 클래스를 사용하지 않고도 컴포넌트의 상태오 라이프사이클을 관리할 수 있게 되었다.

그러나 여전히 클래스는 컴포넌트 개발에 사용되고 있다.
